#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_scalar_block_layout : enable

struct vertex {
	vec3 pos;
	vec3 color;
};

layout(std430, binding = 0) buffer lay0 { //Input
	float heightmap[];
};

layout(std430, binding = 1) buffer lay1 { //Output 
	vertex verticesOut[];
}; 

layout(std430, binding = 2) uniform UBO {
	uint realWorldDistance;
	uint chunkSize;
} UFV;

float normalizef(float value, float min, float max){
	return (value - min) / (max - min);
}

void main() {

	uint meshPos = gl_GlobalInvocationID.x * UFV.chunkSize * UFV.chunkSize;
	uint yPos = gl_GlobalInvocationID.y * UFV.chunkSize;
	uint xPos = gl_GlobalInvocationID.z;

	float height = heightmap[meshPos + yPos + xPos];

	float offset = gl_GlobalInvocationID.y * UFV.realWorldDistance * UFV.chunkSize;

	vertex v;

	v.pos = vec3(gl_GlobalInvocationID.y, gl_GlobalInvocationID.z, height);

	if(height >= 0.9)
		v.color = vec3(0.8, 0.8, 0.8);
	else if(height >= 0.8)
		v.color = vec3(0.55, 0.6, 0.7);
	else if(height >= 0.7)
		v.color = vec3(0.4, 0.45, 0.5);
	else if(height >= 0.5)
		v.color = vec3(0.4, 0.5, 0.45);
	else if(height >= 0.3)
		v.color = vec3(0.3, 0.4, 0.35);
	else if(height >= 0.2)
		v.color = vec3(0.7, 0.6, 0.6);
	else
		v.color = vec3(0.2, 0.3, 0.7);

	verticesOut[meshPos + yPos + xPos] = v;
}