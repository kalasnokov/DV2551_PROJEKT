#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_scalar_block_layout : enable

struct vertex {
	vec3 pos;
	vec3 color;
};

layout(std430, binding = 0) buffer lay0 { //Input
	float heightmap[];
};

layout(std430, binding = 1) buffer lay1 { //Output 
	vertex verticesOut[];
}; 

layout(std430, binding = 2) uniform UBO {
	uint realWorldDistance;
	uint chunkSize;
} UFV;

float normalizef(float value, float min, float max){
	return (value - min) / (max - min);
}

void main() {

	uint meshPos = gl_GlobalInvocationID.x * UFV.chunkSize * UFV.chunkSize;
	uint yPos = gl_GlobalInvocationID.y * UFV.chunkSize;
	uint xPos = gl_GlobalInvocationID.z;

	float height = heightmap[meshPos + yPos + xPos];

	float offset = gl_GlobalInvocationID.y * realWorldDistance * chunkSize;

	vertex v;

	v.pos = vec3(gl_GlobalInvocationID.y, gl_GlobalInvocationID.z, height);

	if(height >= 0.9)
		v.color = vec3(204.0, 211.0, 224.0);
	else if(height >= 0.8)
		v.color = vec3(137.0, 147.0, 165.0);
	else if(height >= 0.7)
		v.color = vec3(96.0, 102.0, 114.0);
	else if(height >= 0.5)
		v.color = vec3(90.0, 117.0, 98.0);
	else if(height >= 0.3)
		v.color = vec3(59.0, 89.0, 68.0);
	else if(height >= 0.2)
		v.color = vec3(183.0, 147.0, 141.0);
	else
		v.color = vec3(47.0, 75.0, 145.0);

	verticesOut[meshPos + yPos + xPos] = v;
}